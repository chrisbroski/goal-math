<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
<title>Goal Mathematics - Tuning Variables</title>
<link rel="stylesheet" href="simple.css">
<style type="text/css">
#variableParams {
    table-layout: fixed;
    width: 360px;
    border-collapse: collapse;
}
#variableParams th, #variableParams td {
    text-align: center;
    border: 2px solid #fff;
}
#variableParams tfoot td {
    font-weight: bold;
}
#variableParams tbody td {
    height: 200px;
    background: #fafafa;
    border-top: 1px solid #eee;
}

.data thead td {
    padding: 8px;
    font-weight: bold;
}
.data td, .data th {
    text-align: center;
    font-weight: normal;
    border: 1px solid #ccc;
}
.data tr.matched td, .data tr.matched th {
    background: #eee;
}
input[type="number"] {
    text-align: right;
    width: 4em;
}
#ssLog {
    padding: 4px;
    background: #333;
    color: #fff;
    width: 360px; height: 180px;
    overflow: auto;
}
</style>

<body>

<article>
<h1>Virtual Subjective Senses</h1>

<h2>Opinions (Virtual Subjective Senses)</h2>

<table id="vss" class="data">
<thead><tr><td>Situation</td><td>Associated Subjective Sense</td></tr></thead>
<tbody>
    <tr><th>0, 0</th><td>0.0</td></tr>
    <tr><th>0, 1</th><td>0.0</td></tr>
    <tr><th>1, 0</th><td>0.0</td></tr>
    <tr><th>1, 1</th><td>0.0</td></tr>
</tbody>
</table>

<h2>Variable Parameters for Action B</h2>

<table id="variableParams"></table>

<p><p><button onclick="turn()">Turn</button>
<p><label>Effect: <input type="number" value="10" id="effect"></label>

<h2>Subjective Sense Log</h2>
<pre id="ssLog"></pre>

<table id="behaviors" class="data">
<thead><tr><td>Situation<br>(Sensor 1, 2)<td>Action, Parameter

<tbody>
<tr class="matched"><th>0, 0</th><td>X</td>
<tr><th>0, 1</th><td>A</td>
<tr><th>1, 0</th><td>B</td>
<tr><th>1, 1</th><td>B</td>
</table>

</article>

<script>

/*
Oh god, does everything I do create more questions than it answers?

Let's start with 25% chance for each situation: 00, 01, 10, 11
Move A will change into a 10 or 11 (50%)
Move B params over minimum will increase the likelihood of a 11 turning into a 01
Move #3: Wait. Costs a small amount of energy to get a new turn. Happens automatically
*/

/*
"current state": situation, previous situation, action, action parameters, subjective senses, action effects
"persistent table" data: behaviors, variable parameters, actions
"logical flow": consistent order of actions that should work step-wise or time interval

    1. generate situation
        a. take into account effects from actions
        b. set state: situation and previous situation
    2. Handle subjective sense data
        a. Add VSS to CSSA *
        b. Aggregate CSSA *
        c. Tune action parameters
        d. Calculate and update VSS for previous situation
        e. Clear CSSA
    3. check behavior table
    4. perform action
        a. set state: current action
        b. get proper variable parameters
        c. set state: variable parameters
        d. set state: action effects

TODO:

    add vss to current ss array
    variable action parameters should be based on action AND situation
    vss should be from a table with HTML render
    behavior table should be a data table with HTML render
*/

var elSsLog = document.getElementById("ssLog"),
    actions = {},
    variables = {},
    current = {
        situation: [0, 0],
        previous_situation: [0, 0],
        action: "X",
        action_parameter: 0.0,
        subjective_senses: [],
        action_effects: [1.0, 1.0]
    };

variables.B = [
    {"val": 1.0, "p": 0.0},
    {"val": 2.0, "p": 0.5},
    {"val": 3.0, "p": 0.5},
    {"val": 4.0, "p": 0.5},
    {"val": 5.0, "p": 0.0},
    {"val": 6.0, "p": 0.0}
];

function log(msg) {
    var logLine = document.createTextNode(msg + "\n");
    elSsLog.appendChild(logLine);
    elSsLog.scrollTop = elSsLog.scrollHeight;
}

function getVar(vTable, val) {
    var ii, len = vTable.length;
    for (ii = 0; ii < len; ii += 1) {
        if (vTable[ii].val === val) {
            return vTable[ii];
        }
    }

    return {};
}

function normalizeVariables() {
    // check if any params are over 1.0
    var highest = 0.0;
    variables.B.forEach(function (p) {
        if (p.p > highest) {
            highest = p.p;
        }
    });

    // if so, divide all by whatever is needed to normalize
    if (highest > 1.0) {
        variables.B = variables.B.map(function (p) {
            return {"val": p.val, "p": p.p / parseFloat(highest)};
        });
    }
}

function vss(ss) {
    var situation = document.querySelector(".matched th").textContent,
        vssRows = document.querySelectorAll("#vss tbody tr"),
        ii,
        len = vssRows.length,
        existingVss,
        newVss;

    for (ii = 0; ii < len; ii += 1) {
        if (vssRows[ii].getElementsByTagName("th")[0].textContent === situation) {
            existingVss = parseFloat(vssRows[ii].getElementsByTagName("td")[0].textContent);
            newVss = (existingVss + ss) / 2;
            vssRows[ii].getElementsByTagName("td")[0].textContent = newVss.toPrecision(3)
            return;
        }
    }
}

actions.X = function () {
    current.subjective_senses.push(-0.001);
}

actions.A = function () {
    current.subjective_senses.push(-0.01);
    current.action_effects[0] = 2.0;
}

actions.B = function () {
    current.subjective_senses.push(current.action_parameter / 100.0 * -1);

    if (current.situation[0]) {
        current.subjective_senses.push((current.action_parameter >= 3.0) ? 0.045 : 0.0);
    }
}

function getFirstOver(a, threshold) {
    var ii, len = a.length;
    for (ii = 0; ii < len; ii += 1) {
        if (threshold < a[ii]) {
            return ii;
        }
    }
    return -1;
}

function getVariableParam() {
    var sum,
        lvls = [];

    if (!variables[current.action]) {
        return 0.0;
    }

    sum = variables[current.action].reduce(function (a, b) {
        return a + b.p;
    }, 0.0);

    variables[current.action].forEach(function (lvl, index) {
        if (index === 0) {
            lvls.push(lvl.p);
        } else {
            lvls.push(lvl.p + lvls[index - 1]);
        }
    });

    lvls = lvls.map(function (val) {
        return val / sum;
    });

    return variables[current.action][getFirstOver(lvls, Math.random())].val;
}

function act() {
    var action_msg;

    // clear previous action effects
    current.action_effects[0] = 1.0;
    current.action_effects[1] = 1.0;

    if (current.action_parameter) {
        action_msg = current.action + ", " + current.action_parameter;
    } else {
        action_msg = current.action;
    }
    log("action: " + action_msg);

    actions[current.action]();
}

function clearTable(t) {
    while (t.rows.length > 0) {
        t.deleteRow(0);
    }
}

function displayVariables() {
    var varTable = document.getElementById("variableParams"),
        varThead = document.createElement("tfoot"),
        varTheadRow = varThead.insertRow(),
        varTbody = document.createElement("tbody"),
        varTbodyRow = varTbody.insertRow();

    variables.B.forEach(function (v) {
        var theadCell = varTheadRow.insertCell(),
            tbodyCell = varTbodyRow.insertCell(),
            val = (v.p * 100.0).toPrecision(3);

            theadCell.textContent = v.val.toPrecision(2);

            if (val > 0.0) {
                tbodyCell.style.background = "linear-gradient(0deg, gainsboro " + val + "%, #fafafa " + val + "%)";
            } else {
                tbodyCell.style.background = "";
            }

            tbodyCell.textContent = v.p.toPrecision(2);
    });

    varTable.appendChild(varThead);
    varTable.appendChild(varTbody);
}

function behaviorTable() {
    var textMatch = current.situation[0] + ", " + current.situation[1];

    // reset current action state
    current.action = "X";

    // find behavior - this should be done in a data structure and not an HTML table
    [].forEach.call(document.querySelectorAll("#behaviors th"), function(el) {
        if (el.textContent === textMatch) {
            el.parentElement.className = "matched";
            current.action = el.nextSibling.textContent;
        } else {
            el.parentElement.className = "";
        }
    });

    current.action_parameter = getVariableParam();
}

function generateSituation() {
    current.previous_situation = current.situation;
    current.situation = current.situation.map(function (perception, index) {
        var rnd = Math.random(),
            likelihood = 0.500000000; // this is a product of the environment
        return (rnd * current.action_effects[index] > likelihood) ? 1 : 0;
    });
}

function subjectiveSenses() {
    var ssAggregate = current.subjective_senses.reduce(function (a, b) {
            return a + b;
        }, 0.0),
        v,
        effect;

    if (current.action_parameter) {
        effect = parseFloat(document.getElementById('effect').value);
        // tune the variable
        v = getVar(variables[current.action], current.action_parameter);
        v.p = parseFloat(v.p) + ssAggregate * effect;
        if (v.p < 0.0) {
            v.p = 0.0;
        }
        normalizeVariables(variables[current.action_parameter]);
    }
    clearTable(document.getElementById('variableParams'));
    displayVariables();
    vss(ssAggregate);
    console.log(JSON.stringify(current));
    // Clear persistent subjective senses
    current.subjective_senses.length = 0;
    log("  ssEnergy: " + ssAggregate.toPrecision(2));
}

function turn() {
    generateSituation();
    subjectiveSenses();
    behaviorTable();
    act();
}

window.onload = turn;
</script>
