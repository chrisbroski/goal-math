<!doctype html>
<html>
<head>
<title>Find Value</title>
<style>
/*! simple.css | MIT License | github.com/chrisbroski/simple-css/ */
* {box-sizing: border-box; }
html {padding: 10px 10px 200px; font-family: droid sans, sans-serif; }
body {margin: 0 auto; max-width: 580px; position: relative; }
article > *:first-child {margin-top: 0; }
h1 {font-size: 36px; }
p, h5 {font-size: 17px; line-height: 1.4em; }

span {background: #ddd; margin: 0 1em; padding: 0 1em; }
canvas {background: #ddd; }
pre {
    margin: 0;
    padding: 2px;
    width: 320px;
    overflow: auto;
    border: 1px solid;
    position: absolute;
    left: 280px;
}
</style>

<body>
<article>
<h1>Find Value</h1>

<pre></pre>
<p><canvas id="graph" width="240" height="140"></canvas>
<p><label>Sensitivity: <input type="number" value="1e-8"></label>
<p>
    <button onclick="singleSearch(searchRand)">Search Random &gt; sensitivity</button>
    <button onclick="multiSearch(100000, searchRand)">x100,000</button>
<p>
    <button onclick="singleSearch(searchUniform, .01)">Search Uniform 1%  &gt; sensitivity</button>
    <button onclick="multiSearch(100000, searchUniform, .01)">x100,000</button>
<p>
    <button onclick="singleSearch(searchUniform, PHI)">Search Uniform 61.8%  &gt; sensitivity</button>
    <button onclick="multiSearch(100000, searchUniform, PHI)">x100,000</button>
<p>
    <button onclick="singleSearch(searchRand, null, 0.788)">Search Random &gt; 0.788</button>
    <button onclick="multiSearch(100000, searchRand, null, 0.788)">x100,000</button>
<p>
    <button onclick="singleSearch(searchUniform, PHI, 0.788)">Search Uniform 61.8%  &gt; 0.788</button>
    <button onclick="multiSearch(100000, searchUniform, PHI, 0.788)">x100,000</button>
</article>

<script>
var maxX = 200;
var sqrtOfOneDiv2Pi = Math.sqrt(1 / (2 * Math.PI));
var PHI = 0.61803398875;
var mean = 100;
var std = 2;
var turn = 0;
var canvas;
var ctx;
var precision = 3;
var sensitivity = 0.00000001;
// var success = 0.7878896; // max - 1%
var boundaries = {left: 0, right: 200, potential: [], best: [0, 0]};

function drawRule() {
    ctx.beginPath();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.moveTo(10.5, 120.5);
    ctx.lineTo(230.5, 120.5);
    ctx.moveTo(20.5, 20.5);
    ctx.lineTo(20.5, 130.5);
    ctx.stroke();
}

// Where did I find this? It seems to work but I don't know why.
function pdf(x, mean, std) {
    var base = sqrtOfOneDiv2Pi / std;
    var exp = 1 / (2 * std * std);
    var diff = x - mean;
    var y = base * Math.exp(-diff * diff * exp);
    return y;
}
// I like the simplicity of this but it is inconsistent with a lot of statistical norms
function pdfStigler(x, mean) {
    y = Math.exp(x * x * Math.PI * -1);
    console.log(x, y);
    return y;
}

function dist(x) {
    return pdf(x, mean, std) * std * 2;
}

function drawGraph() {
    var val, ii, len = maxX;

    ctx.beginPath();
    for (ii = 0; ii < len; ii += 1) {
        val = dist(ii);
        ctx.lineTo(20 + ii, 120.5 - val * 100);
    }
    ctx.stroke();
}

function newPeak() {
    turn = 0;
    mean = Math.random() * maxX;
    std = 4;//Math.random() * 16 + 0.5;
    // display();
    drawRule();
}

function tryOne(e) {
    var rect = e.target.getBoundingClientRect();
    var x = e.clientX - rect.left - 20;
    // var x = e.pageX - this.offsetLeft - 20;
    var y = dist(x);
    turn += 1;
    // display(y);
}

function clearBoundaries() {
    boundaries.left = 0;
    boundaries.right = 200;
    boundaries.potential.length = 0;
    boundaries.best[0] = 0;
    boundaries.best[1] = 0;
}

function findNext(previous, interval) {
    var range = boundaries.right - boundaries.left;
    var x = previous + interval * range;

    if (x > boundaries.right) {
        x = x - range;
    }
    return x;
}

function updateSearchSpace(x, y) {
    // normalize sensitivity threshold to zero
    if (y < sensitivity) {
        y = 0;
    }
    // record this attempt
    // if (boundaries.potential.some(function (attempt) {
    //     return attempt[0] === x;
    // })) {
        boundaries.potential.push([x, y]);
    // }

    if (y === 0 && boundaries.best[1] === 0) {
        // if there is no best yet, then just move on
        // console.log("y=0 and no best yet");
        return;
    }

    if (y > boundaries.best[1]) {
        boundaries.best[0] = x;
        boundaries.best[1] = y;
        // console.log("record best [" + x + ", " + y + "]");
    }

    if (boundaries.potential.length < 2) {
        // We'll need at least 2 points
        // console.log("1 attempt is not enough to modify search space");
        return;
    }

    // sort by x
    boundaries.potential.sort(function (a, b) {
        return a[0] - b[0];
    });

    // left should become the potential one less than max
    // right is the potential one greater
    boundaries.potential.forEach(function (attempt, index, potentials) {
        // console.log(attempt, index);
        if (attempt[0] === boundaries.best[0]) {
            // console.log(attempt[0] + " is best")
            if (index > 0) {
                boundaries.left = potentials[index - 1][0];
            }
            if (index < potentials.length - 1) {
                boundaries.right = potentials[index + 1][0];
            }
        }
    });
}

function searchUniform(interval, success, display) {
    var x, y = 0, iter = 0;
    x = Math.random() * boundaries.right;
    clearBoundaries();
    if (display) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawRule();
        drawGraph();
    }

    while (y <= success) {
        iter += 1;
        x = findNext(x, interval);

        if (display) {
            ctx.beginPath();
            ctx.moveTo(x + 20.5, 120.5);
            ctx.lineTo(x + 20.5, 20.5);
            ctx.stroke();
        }

        y = dist(x);
        updateSearchSpace(x, y, display);
    }

    return iter;
}

function searchRand(interval, success, display) {
    var x, y = 0, iter = 0, range;
    clearBoundaries();
    if (display) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawRule();
        drawGraph();
    }

    while (y <= success) {
        iter += 1;
        range = boundaries.right - boundaries.left;
        x = Math.random() * range + boundaries.left;

        if (display) {
            ctx.beginPath();
            ctx.moveTo(x + 20.5, 120.5);
            ctx.lineTo(x + 20.5, 20.5);
            ctx.stroke();
        }

        y = dist(x);
        updateSearchSpace(x, y, display);
    }

    return iter;
}

function aveMean(a) {
    var total = a.reduce(function (a, b) {
        return a + b;
    });
    return total / a.length;
}

function meanDev(a, x) {
    var total = a.reduce(function (a, b) {
        return a + Math.abs(b - x);
    });
    return total / a.length;
}

function singleSearch(choice, param, success) {
    var tries, out = document.querySelector("pre"), text;
    newPeak();
    success = success || sensitivity;
    text = document.createTextNode("Search " + choice.name + "\n");
    out.appendChild(text);
    tries = choice(param, success, true);
    // ave = aveMean(history);
    text = document.createTextNode("    Tries: " + tries + "\n");
    out.appendChild(text);
    // text = document.createTextNode("    Mean variance: " + meanDev(history, ave).toPrecision(precision) + "\n");
    // out.appendChild(text);
}

function multiSearch(iterations, choice, param, success) {
    var ii, tries, history = [], ave, out = document.querySelector("pre"), text;
    success = success || sensitivity;
    text = document.createTextNode("Search " + choice.name + " " + iterations + " attempts\n");
    out.appendChild(text);
    for (ii = 0; ii < iterations; ii += 1) {
        newPeak();
        tries = choice(param, success);
        history.push(tries);
    }
    ave = aveMean(history);
    text = document.createTextNode("    Mean: " + ave.toPrecision(precision) + "\n");
    out.appendChild(text);
    text = document.createTextNode("    Mean variance: " + meanDev(history, ave).toPrecision(precision) + "\n");
    out.appendChild(text);
}

function init() {
    canvas = document.getElementById("graph");
    ctx = canvas.getContext("2d");

    ctx.lineWidth = 1;
    ctx.strokeStyle = 'black';
    ctx.font = '12px sans-serif';

    newPeak();
    drawGraph();

    canvas.addEventListener("click", tryOne);
    document.getElementById("new").addEventListener("click", newPeak);
    document.getElementById("show").addEventListener("click", drawGraph);
}

init();
/*
1. Search behavior
2. Once found, find optimal
3. At some point, expand outside solution space
*/
</script>
